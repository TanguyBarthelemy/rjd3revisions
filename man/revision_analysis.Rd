% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/revision_analysis.R
\name{revision_analysis}
\alias{revision_analysis}
\title{Revision analysis through a battery of tests}
\usage{
revision_analysis(
  vintages,
  gap = 1,
  view = c("vertical", "diagonal"),
  n.releases = 3,
  transf.diff = c("auto", "forced", "none"),
  transf.log = FALSE,
  descriptive.rounding = 3,
  nrevs = 1,
  ref = 1,
  na.zero = FALSE
)
}
\arguments{
\item{vintages}{an object of class \code{"rjd3rev_vintages"} which is the output
of the function \code{create_vintages()}}

\item{gap}{Integer. Gap to consider between each vintages. Default is 1
which means that revisions are calculated and tested for each
vintages consecutively.}

\item{view}{Selected view. Can be "vertical" (the default) or "diagonal".
Vertical view shows the observed values at each time period by
the different vintages. Diagonal view shows subsequent releases
of a given time period, without regard for the date of
publication, which can be particularly informative when regular
estimation intervals exist. See \code{?create_vintages()} for more
information about interests and drawbacks of each view.}

\item{n.releases}{only used when \code{view = "diagonal"}. Ignored otherwise.
Allow the user to limit the number of releases under
investigation). When \code{view = "vertical"}, the user is
invited to limit the number of vintages upstream through
the parameter \code{vintage_selection} in \code{create_vintages()}
whenever necessary.}

\item{transf.diff}{differentiation to apply to the data prior testing. Only
used for regressions including vintage data as regressor
and/or regressand. Regression including revision data only
are never differentiated even if \code{transf.diff = "forced"}.
Options are "automatic" (the default), "forced" and "none".}

\item{transf.log}{Boolean whether a log-transformation should first be
applied to the data. Default is FALSE.}

\item{descriptive.rounding}{Integer. Number of decimals to display for
descriptive statistics. Default is 3.}

\item{nrevs, ref}{Integer. Number of lags to consider for orthogonality tests
1 and 2 respectively.}

\item{na.zero}{Boolean whether missing values should be considered as 0 or
rather as data not yet available (the default).}
}
\value{
an object of class 'rjd3rev_rslts'
}
\description{
The function perform parametric tests which enable the users to detect
potential bias (both mean and regression bias) and sources of inefficiency in
preliminary estimates. We would conclude to inefficiency in the preliminary
estimates when revisions are predictable in some way. In the results,
parametric tests are divided into 5 categories: relevancy (check whether
preliminary estimates are even worth it), bias, efficiency, orthogonality
(correlation at higher lags), and signalVSnoise. Descriptive statistics on
revisions are also provided. For some of the parametric tests, prior
transformation of the vintage data may be important to avoid misleading
results. By default, the decision to differentiate the vintage data is
performed automatically based on unit root and co-integration tests whose
results can be found found in the results too (section 'varbased'). Finally,
running the function \code{render_report()} on the output of \code{revision_analysis()}
would give you both a formatted summary of the results and full explanations
about each tests.
}
\examples{

## Simulated data
period_range <- seq(as.Date('2011-01-01'),as.Date('2020-10-01'),by='quarter')
qtr <- (as.numeric(substr(period_range,6,7))+2)/3
time_period <- rep(paste0(format(period_range, "\%Y"), "Q", qtr),5)
np <- length(period_range)
rev_date <- c(rep("2021-06-30",np), rep("2021-12-31",np), rep("2022-06-30",np),
            rep("2022-12-31",np), rep("2023-06-30",np))
set.seed(1)
xt <- cumsum(sample(rnorm(1000,0,1), np, TRUE))
rev <- rnorm(np*4,0,.1)
obs_values <- xt
for(i in 1:4) {
  xt <- xt+rev[(1+(i-1)*np):(i*np)]
  obs_values <- c(obs_values,xt)
}
df <- data.frame(rev_date, time_period, obs_values)

## Create a `"rjd3rev_vintages"` object with the input
vintages <- create_vintages(x = df, periodicity = 4, date_format = "\%Y-\%m-\%d")
# revisions <- get_revisions(vintages, gap = 1) # just to get a first insight of the revisions

## Call using all default parameters
rslt1 <- revision_analysis(vintages)
# render_report(rslt1)
# summary(rslt1) # formatted summary only

## Calls using diagonal view (suited in many situations such as to evaluate GDP estimates)
## Note: when input are not growth rates but the gross series, differentiation is
## performed automatically (if transf.diff is let to its default option) but `transf.log`
## must be set to TRUE manually whenever a log-transformation of the data is necessary
rslt2 <- revision_analysis(vintages, gap = 1, view = "diagonal", n.releases = 3)
# render_report(rslt2)
# summary(rslt2)

## Call to evaluate revisions for a specific range of vintage periods
vintages <- create_vintages(
    x = df,
    periodicity = 4,
    vintage_selection = c(start="2021-12-31", end="2023-06-30")
)
rslt3 <- revision_analysis(vintages, gap=2, view = "vertical")
#render_report(rslt3)
#summary(rslt3)

## Note that it is possible to change thresholds values for quality
## assessment using options (see vignette for details)
options(augmented_t_threshold = c(severe = 0.005, bad = 0.01, uncertain = 0.05),
        slope_and_drift_threshold = c(severe = 0.005, bad = 0.05, uncertain = 0.10),
        theil_u2_threshold = c(uncertain = .5, bad = .7, severe = 1))
rslt4 <- revision_analysis(vintages, gap = 1, view = "diagonal", n.releases = 3)
summary(rslt4)

}
\seealso{
\code{create_vintages()} to create the input object,
\code{render_report()} to get a summary and information the tests
}
